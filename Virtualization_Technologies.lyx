#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Virtualization Technologies Vademecum
\end_layout

\begin_layout Author
Giuseppe Nebbione
\end_layout

\begin_layout Section
Tecnologie di Virtualizzazione
\end_layout

\begin_layout Standard
In informatica per 
\begin_inset Quotes eld
\end_inset

virtualizzazione
\begin_inset Quotes erd
\end_inset

 si intende l'atto di creare/gestire una versione virtuale di qualcosa,
 come un computer con hardware virtuale, sistemi operativi, dispositivi
 di storage, o risorse di rete.
\end_layout

\begin_layout Standard
In hardware virtualization, the host machine is the actual machine on which
 the virtualization takes place, and the guest machine is the virtual machine.
 The software or firmware that creates a virtual machine on the host hardware
 is called a hypervisor or Virtual Machine Manager.
\end_layout

\begin_layout Standard
Different types of hardware virtualization include:
\end_layout

\begin_layout Itemize
Full virtualization – almost complete simulation of the actual hardware
 to allow software, which typically consists of a guest operating system,
 to run unmodified.
 
\end_layout

\begin_layout Itemize
Partial virtualization – some but not all of the target environment attributes
 are simulated.
 As a result, some guest programs may need modifications to run in such
 virtual environments.
 
\end_layout

\begin_layout Itemize
Paravirtualization – a hardware environment is not simulated; however, the
 guest programs are executed in their own isolated domains, as if they are
 running on a separate system.
 Guest programs need to be specifically modified to run in this environment.
 
\end_layout

\begin_layout Standard
C'è differenza tra emulazione e virtualizzazione
\end_layout

\begin_layout Itemize
Emulazione: Un pezzo di software o hardware (esistono device per l'emulazione)
 imita un'altro pezzo di hardware (un'altra CPU), quindi ad esempio ho un
 x86 che imita un PowerPC
\end_layout

\begin_layout Itemize
Virtualizzazione: Un pezzo di software (chiamato hypervisor o VMM (virtual
 machine manager) ) imita un pezzo particolare del computer o l'intero sistema
\end_layout

\begin_layout Standard
Per quanto riguarda la virtualizzazione, esistono due tipi di hypervisor:
\end_layout

\begin_layout Itemize
Type 1 (native or bare-metal hypervisors): Questi hypervisor runnano direttament
e sull'hardware del sistema host e non hanno bisogno di software( o sistemi
 operativi supplementari) esempi di questi sono: Citrix XenServer, Microsoft
 Hyper-V, Oracle VM Server for x86 (or Sparc), VMware ESX/ESXi
\end_layout

\begin_layout Itemize
Type 2 (hosted hypervisor): Questi hypervisor runnano su un sistema operativo
 convenzionale e hanno quindi bisogno di un sistema operativo host su cui
 runnare, esempi di questi sono: VirtualBox, Qemu, VMware
\end_layout

\begin_layout Standard
Comunque la distizione tra questi due tipi non è del tutto chiara, ad esempio
 esistono moduli in GNU/Linux e FreeBSD che rendono in modo efficace un
 sistema operativo host ad un hypervisor di tipo 1; però è da considerare
 che essendo questi ultimi (GNU/Linux e FreeBSD) OS general purpose, l'hyperviso
r dovrà comunque condividere risorse col resto dell'OS, quindi vengono da
 molti considerati hypervisors 
\begin_inset Quotes eld
\end_inset

type 2
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Chroot
\end_layout

\begin_layout Standard
Una delle più basilare tecnologie di virtualizzazione che possono essere
 utilizzate sono i 
\begin_inset Quotes eld
\end_inset

chroot
\begin_inset Quotes erd
\end_inset

, questa tecnologia è molto primitiva.
 Molto semplice da applicare:
\end_layout

\begin_layout Itemize
export MY_CHROOT=
\begin_inset Quotes erd
\end_inset

/directory
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
mount proc $MY_CHROOT/proc -t proc
\end_layout

\begin_layout Itemize
echo "proc $MY_CHROOT/proc proc defaults 0 0" >> /etc/fstab //rende le modifiche
 permanenti
\end_layout

\begin_layout Itemize
echo "sysfs $MY_CHROOT/sys sysfs defaults 0 0" >> /etc/fstab //rende le
 modifiche permanenti
\end_layout

\begin_layout Itemize
mount sysfs $MY_CHROOT/sys -t sysfs
\end_layout

\begin_layout Itemize
cp /etc/hosts $MY_CHROOT/etc/hosts
\end_layout

\begin_layout Itemize
cp /proc/mounts $MY_CHROOT/etc/mtab
\end_layout

\begin_layout Itemize
chroot /directory/ /bin/bash
\end_layout

\begin_layout Standard
ora prima di eseguire un chroot possiamo costruire un semplice sistema linux,
 questo può essere fatto in vari modi, possiamo addirittura utilizzare gli
 strumenti messi a disposizione da varie distribuzioni per creare lo scheletro
 di una distro minimale, ad esempio per gentoo, posso scaricare uno stage3
 dal sito ufficiale, per debian posso semplicemente utilizzare debootstrap.
\end_layout

\begin_layout Standard
Per poter avviare applicazioni grafiche possiamo semplicemente utilizzare
 un comando prima di entrare nel chroot, il comando è:
\end_layout

\begin_layout Itemize
xhost local:localuser
\end_layout

\begin_layout Standard
Attenzione non possiamo usare systemctl ed in genere systemd per manipolare
 i servizi all'interno del chroot, questo è un problema noto di systemd,
 systemd implementa una sua soluzione di virtualizzazione simile ad LXC
 (ma al momento meno intuitiva e semplice), chiamata systemd-nspawn, questo
 viene considerato una specie di chroot pompato.
\end_layout

\begin_layout Section
Qemu
\end_layout

\begin_layout Standard
Qemu è sia un emulatore che un sistema di virtualizzazione con hypervisor
 
\begin_inset Quotes eld
\end_inset

type 2
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Installazione
\end_layout

\begin_layout Standard
prima di installarlo è nostro compito verificare se il sistema host possiede
 una CPU che supporta estensioni di virtualizzazione (Intel VT o AMD-V),
 per verificare la presenza di queste estensioni ci basta eseguire:
\end_layout

\begin_layout Itemize
egrep '(vmx|svm)' /proc/cpuinfo //se l'output non è vuoto, allora la CPU
 possiede estensioni di virtualizzazione
\end_layout

\begin_layout Standard
possedere estensioni di virtualizzazione ci permette di avere una virtualizzazio
ne più efficiente e veloce attraverso il modulo KVM, per installarlo con
 KVM eseguiamo:
\end_layout

\begin_layout Itemize
apt-get install kvm qemu-kvm libvirt-bin //per installarlo con KVM
\end_layout

\begin_layout Itemize
yum install qemu-kvm
\end_layout

\begin_layout Itemize
yast -i kvm
\end_layout

\begin_layout Standard
mentre nel caso in cui avessimo una CPU senza estensioni di virtualizzazione
 allora installeremo
\end_layout

\begin_layout Itemize
apt-get install qemu qemu-kvm libvirt-bin
\end_layout

\begin_layout Itemize
yum install qemu
\end_layout

\begin_layout Itemize
yast -i qemu
\end_layout

\begin_layout Standard
N.B.: QEMU can make use of KVM when running a target architecture that is
 the same as the host architecture.
 For instance, when running qemu-system-x86 on an x86 compatible processor,
 you can take advantage of the KVM acceleration - giving you benefit for
 your host and your guest system.
 
\end_layout

\begin_layout Subsubsection
Dischi Immagine supportati da Qemu
\end_layout

\begin_layout Standard
Una volta installato, QEMU è pronto per runnare un OS guest (ospite) caricato
 da un immagine disco.
 Questo tipo di immagine rappresenta dati su un hard disk, possiamo pensare
 a questo come un hard disk virtuale.
 Per mettere in running un immagine disco, eseguiamo:
\end_layout

\begin_layout Itemize
qemu myImageDisc.img //mette in running l'immagine di un OS
\end_layout

\begin_layout Standard
possiamo fare in modo che Qemu prenda il controllo del mouse, clickando
 nella finestra relativa, mentre per far rilasciare il mouse schiacciamo
 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Qemu supporta diversi tipi di immagine, ma la sua immagine nativa e più
 flessibile è la 
\begin_inset Quotes eld
\end_inset

qcow2
\begin_inset Quotes erd
\end_inset

 che supporta:
\end_layout

\begin_layout Itemize
il 
\begin_inset Quotes eld
\end_inset

copy on write
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
encryption
\end_layout

\begin_layout Itemize
compressione
\end_layout

\begin_layout Itemize
snapshot di macchine virtuali
\end_layout

\begin_layout Standard
anche se Qemu supporta correntemente questi formati di immagine disco:
\end_layout

\begin_layout Itemize
raw: questo è un formato binario semplice di un'immagine disco ed è molto
 portable
\end_layout

\begin_layout Itemize
cloop: Compressed Loop format, usata principalmente per particolari immagini
 live come Knoppix e altri cd live
\end_layout

\begin_layout Itemize
cow: immagine copy on write, supportata per ragioni storiche
\end_layout

\begin_layout Itemize
qcow: immagina nativa di qemu, versione precedente, supportata per questioni
 di compatibilità
\end_layout

\begin_layout Itemize
qcow2: immagine nativa di qemu
\end_layout

\begin_layout Itemize
vmdk: immagine di VMware
\end_layout

\begin_layout Itemize
vdi: immagine di Virtualbox
\end_layout

\begin_layout Subsubsection
Creazione di un'immagine disco (ovvero come fare il set up di un sistema
 guest)
\end_layout

\begin_layout Standard
Per creare il nostro OS ospite (guest) dobbiamo prima creare un'immagine
 disco vuota.
 Qemu utilizza il comando 
\begin_inset Quotes eld
\end_inset

qemu-img
\begin_inset Quotes erd
\end_inset

 per creare e manipolare immagini disco, il formato di default con cui crea
 le immagini è quello 
\begin_inset Quotes eld
\end_inset

Raw
\begin_inset Quotes erd
\end_inset

, vediamo come fare:
\end_layout

\begin_layout Itemize
qemu-img create -f qcow2 miaImg.img 10G //creiamo un'immagine di tipo qcow2,
 di nome 
\begin_inset Quotes eld
\end_inset

miaImg.img
\begin_inset Quotes erd
\end_inset

 e di dimensione massima pari a 10GB 
\end_layout

\begin_layout Itemize
qemu-img resize miaImg.img +10G //aumenta di 10GB la dimensione dell'immagine
 menzionata, non è ancora possibile per le immagini qcow2 rimpicciolire
 le immagini
\end_layout

\begin_layout Standard
una volta creata l'immagine possiamo eseguire il boot di una ISO di un OS
 con il comando 
\begin_inset Quotes eld
\end_inset

qemu
\begin_inset Quotes erd
\end_inset

, che su alcuni sistemi può essere 
\begin_inset Quotes eld
\end_inset

kvm
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -hda miaImg.img -cdrom nomeIso.iso -boot
 d //in questo caso stiamo inizializzando un sistema con 256MB di RAM, e
 utilizzando la iso menzionata come immagine montata al boot, ricorda che
 se qemu non viene trovato, dobbiamo usare kvm, solitamente 
\begin_inset Quotes eld
\end_inset

kvm
\begin_inset Quotes erd
\end_inset

 è un'abbreviazione di 
\begin_inset Quotes eld
\end_inset

qemu-system-[myArch] -enable-kvm
\begin_inset Quotes erd
\end_inset

, attenzione se l'architettura emulata ha la stessa architettura
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -hda miaImg.img -cdrom /dev/cdrom -boot
 d //in questo caso viene preso proprio il contenuto del lettore cd/dvd
 del sistema host come boot per l'immagine, al posto di 
\begin_inset Quotes eld
\end_inset

/dev/cdrom
\begin_inset Quotes erd
\end_inset

 potremmo avere 
\begin_inset Quotes eld
\end_inset

/dev/sr0
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

/dev/dvd
\begin_inset Quotes erd
\end_inset

 a differenza della configurazione HW/SW del sistema host
\end_layout

\begin_layout Standard
N.B.: Si può passare in modalità full-screen con la combinazione 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+f
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Vediamo altre opzioni di boot più complessa:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -cpu host -smp 2 -hda miaImg.img -cdrom W7ALLINONE.
iso -boot d -m 1024 -k it -netdev user,id=user.0 -device e1000,netdev=user.0
 -usb -usbdevice tablet -vga qxl -display sdl -monitor stdio //con smp specifich
iamo il numero di processori, con -cpu host specifichiamo la cpu del sistema
 ospitante
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -cpu host -smp 2 -hda miaImg.img -cdrom debian-8.2.0
-amd64-netinst.iso -boot d -m 1024 -usb -vga qxl //per vga esistono diverse
 opzioni, se dovessimo avere problemi col video possiamo provare le altre,
 possiamo analizzarle attraverso 
\begin_inset Quotes eld
\end_inset

man qemu-system-x86_64
\begin_inset Quotes erd
\end_inset

 e poi cercando 
\begin_inset Quotes eld
\end_inset

-vga
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
qemu-system-ppc -hda miaImg.img -cdrom debian-8.2.0-powerpc-netinst.iso -boot
 d -m 1024 -usb //emuliamo un powerpc in questo caso
\end_layout

\begin_layout Subsubsection
Quali CPU ho a disposizione ?
\end_layout

\begin_layout Standard
Per vedere quali CPU possiamo emulare da un terminale premendo:
\end_layout

\begin_layout Itemize
qemu-+TAB //tabbando vedremo le varie architetture disponibili
\end_layout

\begin_layout Standard
una volta selezionata l'architettura generale possiamo anche utilizzare
 un'architettura specifica, utilizzando il flag 
\begin_inset Quotes eld
\end_inset

-cpu ?
\begin_inset Quotes erd
\end_inset

, ad esempio per vedere quali modelli specifici abbiamo per la i processori
 dell'architettura MIPS, eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-mips -cpu ? //in questo caso possiamo vedere i vari modelli
 di CPU disponibili per l'architettura MIPS, una volta visualizzato il modello
 interessato possiamo selezionarlo con:
\end_layout

\begin_layout Itemize
qemu-system-mips -cpu 4Km -hda miaImg.img -cdrom debian_8.0_mips.iso -boot
 d -m 1024
\end_layout

\begin_layout Standard
altre volte per alcune CPU tipo arm, dobbiamo specificare prima il tipo
 di macchina attraverso il comando 
\begin_inset Quotes eld
\end_inset

-machine
\begin_inset Quotes erd
\end_inset

 quindi eseguiremo:
\end_layout

\begin_layout Itemize
qemu-system-arm -machine ? //visualizza le macchine disponibili
\end_layout

\begin_layout Standard
poi sarà possibile utilizzare -cpu ?, quindi eseguiremo:
\end_layout

\begin_layout Itemize
qemu-system-arm -machine NameOfTheMachine -cpu ? //visualizza le cpu disponibili
 per l'architettura e la macchina menzionata
\end_layout

\begin_layout Subsubsection
Opzioni di Boot
\end_layout

\begin_layout Standard
Per il boot esistono diverse opzioni:
\end_layout

\begin_layout Itemize
-boot c //fa il boot dal primo virtual hard drive
\end_layout

\begin_layout Itemize
-boot d //da il boot dal primo CDROM drive virtuale
\end_layout

\begin_layout Itemize
-boot n //fa il boot dalla virtual network
\end_layout

\begin_layout Standard
ATTENZIONE 
\begin_inset Quotes eld
\end_inset

UEFI
\begin_inset Quotes erd
\end_inset

: Per poter effettuare il boot di un sistema uefi doabbiamo installare il
 pacchetto 
\begin_inset Quotes eld
\end_inset

ovmf
\begin_inset Quotes erd
\end_inset

.
 E possiamo avviarlo selezionando come boot:
\end_layout

\begin_layout Itemize
qemu-kvm -bios ./usr/share/qemu-ovmf/bios/bios.bin -m 1G -cdrom boot.iso
\end_layout

\begin_layout Subsubsection
Boot di un'immagine con OS già installato
\end_layout

\begin_layout Standard
una volta installato il sistema da ISO o da CD/DVD possiamo avviare il nostro
 sistema guest con:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -hda miaImg.img -kernel-kqemu //avvia
 il sistema operativo installato con qemu, NOTA BENE, quest'istruzione prevede
 una CPU con 32 bit
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -name debianProva -hda miaImg.img //avvia
 il sistema operativo, e assegna un nome alla macchina virtuale che è 
\begin_inset Quotes eld
\end_inset

debianProva
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -hda miaImg.img -kernel-kqemu //avvia
 il sistema operativo installato con qemu, quest'istruzione è per i sistemi
 a 64 bit, in realtà su alcuni sistemi non c'è bisogno di usare l'opzione
 -kernel-kqemu
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 256 -smp 2 -hda miaImg.img //l'opzione
 
\begin_inset Quotes eld
\end_inset

smp
\begin_inset Quotes erd
\end_inset

 permette di specificare il numero di processori da utilizzare
\end_layout

\begin_layout Standard
Qemu può utilizzare fino a 4 immagini contemporaneamente, in modo che 4
 dischi virtuali vengono presentati contemporaneamente allo stesso OS guest,
 questo è molto utile ad esempio nei seguenti esempi:
\end_layout

\begin_layout Itemize
un immagine disco pagefile o file di swap virtuale che può essere condiviso
 tra più macchine virtuali
\end_layout

\begin_layout Itemize
un disco dati comune a più OS guest che può essere condiviso tra questi
 ultimi
\end_layout

\begin_layout Itemize
dare spazio addizionale ad un OS guest senza riconfigurare o compromettere
 l'immagine principale
\end_layout

\begin_layout Itemize
separare operazioni di I/O su un dispositivo di memoria, andando a salvare
 immagini diverse di Qemu su dispositivi di memoria diversi del sistema
 host
\end_layout

\begin_layout Itemize
emulazione di un ambiente fisico con più dispositivi di memoria per ragioni
 di testing/learning
\end_layout

\begin_layout Standard
E' da ricordare che però solo un'istanza di QEMU può accedere ad un'immagine
 alla volta.
 Per usare più immagini con un sistema operativo guest eseguiamo:
\end_layout

\begin_layout Itemize
qemu -m 256 -hda miaImg.img -hdb miaImg2.img -hdc miaImg3.img -hdd tempFiles.img
 -kernel-kqemu
\end_layout

\begin_layout Standard
NB: QEMU doesn't support both -hdc and -cdrom at the same time, as they
 both represent the first device on the second IDE channe
\end_layout

\begin_layout Standard
Per creare e lanciare una nuova immagine basata su un altro file immagine
 eseguiamo:
\end_layout

\begin_layout Itemize
qemu-img create -f qcow2 -o backing_file=miaImg.img test01.img //crea un nuovo
 file immagine che è un clone di un'altra immagine
\end_layout

\begin_layout Itemize
qemu -m 256 -hda test01.img -kernel-kqemu & //lancia la nuova macchina virtuale
\end_layout

\begin_layout Subsubsection
Montare immagini sul sistema Host
\end_layout

\begin_layout Standard
a volta può essere utile montare immagini disco sul sistema host.
 Ad esempio se il sistema guest non ha un support network, l'unico modo
 per trasferire file da host a guest e viceversa sarà montando l'immagine
 sul sistema host.
 I sistemi Linux e UNIX possono montare immagini create nel formato 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 usando un dispositivo di loopback.
 Da un utente root possiamo montare un'immagine raw con:
\end_layout

\begin_layout Itemize
mount -o loop,offset=32356 /percorso/immagine.img /mnt/mountpoint //monta
 l'immagine 
\begin_inset Quotes eld
\end_inset

RAW
\begin_inset Quotes erd
\end_inset

 su un mountpoint specifico, attenzione l'offset dipende dalla partizione
 specifica che vogliamo montare dell'immagine.img, se abbiamo solo una partizione
 allora possiamo omettere l'opzione offset, inoltre questo comando può montare
 solo immagini RAW
\end_layout

\begin_layout Standard
possiamo determinare l'offset corretto con 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

fdisk -l /percorso/immagine.img
\begin_inset Quotes erd
\end_inset

 //in questo caso quello che dobbiamo guardare è dove inizia la partizione
 interessata e la dimensione di settore 
\begin_inset Quotes eld
\end_inset

sector size
\begin_inset Quotes erd
\end_inset

, se ad esempio la partizione inizia al blocco 128 e il sector size è 512,
 allora l'offset da mettere è 512*128=65536, quindi avremmo dovuto mettere
 offset=65536
\end_layout

\begin_layout Standard
ricordiamo che l'offset serve a specificare la partizione interessata all'intern
o della nostra immagine virtuale, infatti non abbiamo bisogno di specificare
 l'offset se la nostra immagine ha solo una partizione.
\end_layout

\begin_layout Standard
ATTENZIONE: Mai montare un immagine mentre è in utilizzo da Qemu, quest'operazio
ne la compromette.
\end_layout

\begin_layout Standard
Per montare immagini di tipo diverso dal 
\begin_inset Quotes eld
\end_inset

RAW
\begin_inset Quotes erd
\end_inset

, come ad esempio le 
\begin_inset Quotes eld
\end_inset

qcow2
\begin_inset Quotes erd
\end_inset

 allora dobbiamo usare qemu-nbd, dove 
\begin_inset Quotes eld
\end_inset

nbd
\begin_inset Quotes erd
\end_inset

 sta per 
\begin_inset Quotes eld
\end_inset

Network Block Device
\begin_inset Quotes erd
\end_inset

, (questo metodo che verrà descritto in realtà funziona anche con le immagini
 
\begin_inset Quotes eld
\end_inset

RAW
\begin_inset Quotes erd
\end_inset

, solo che siccome il 
\begin_inset Quotes eld
\end_inset

mount
\begin_inset Quotes erd
\end_inset

 è più efficiente, con le RAW preferiamo eseguire quello) eseguiamo quindi:
\end_layout

\begin_layout Itemize
modprobe nbd max_part=16
\end_layout

\begin_layout Itemize
qemu-nbd -c /dev/nbd0 image.qcow2
\end_layout

\begin_layout Itemize
sudo partprobe /dev/nbd0
\end_layout

\begin_layout Itemize
fdisk /dev/nbd0 //visualizziamo informazioni, in modo da capire quale partizione
 ci può interessare
\end_layout

\begin_layout Itemize
mount /dev/nbd0p1 /mnt/image
\end_layout

\begin_layout Standard
E' da ricordare che le partizioni gestite con LVM non possono essere montate
 con 
\begin_inset Quotes eld
\end_inset

mount
\begin_inset Quotes erd
\end_inset

, ma dobbiamo usare i relativi comandi.
\end_layout

\begin_layout Subsubsection
Copiare un immagine virtuale su un Dispositivo di Memoria reale
\end_layout

\begin_layout Standard
It may be desired to copy a diskimage to a physical device.
 An example may be if building a cluster, it might be easier to get everything
 ready in qemu, then write the final diskimage to all of the hard drives.
 Of course your image will need to contain all of required configuration
 and drivers for the new system to boot properly.
\end_layout

\begin_layout Standard
The diskimage will need to be in raw format, quindi prima dovremo convertire
 l'immagine in immagine RAW
\end_layout

\begin_layout Itemize
qemu-img convert -O raw diskimage.qcow2 diskimage.raw //converte in formato
 RAW un'immagine qcow2
\end_layout

\begin_layout Standard
una volta che abbiamo l'immagine in formato raw possiamo eseguire:
\end_layout

\begin_layout Itemize
dd if=diskimage.raw of=/dev/sdX //copia l'immagine RAW su un dispositivo
 reale
\end_layout

\begin_layout Standard
un'alternativa più rapida è eseguire:
\end_layout

\begin_layout Itemize
qemu-img convert -O raw diskimage.qcow2 /dev/sdX //questo converte e scrive
 direttamente su dispositivo fisico
\end_layout

\begin_layout Subsubsection
Informazioni su un'immagine virtuale
\end_layout

\begin_layout Standard
Per ottenere informazioni su un'immagine virtuale eseguiamo:
\end_layout

\begin_layout Itemize
qemu-img info test.vmdk // in questo caso viene fatto il retrieving delle
 informazioni sull'immagine virtuale
\end_layout

\begin_layout Subsubsection
Convertire Immagini
\end_layout

\begin_layout Standard
Per convertire immagini da un formato all'altro seguiamo questo formato
 di istruzione:
\end_layout

\begin_layout Itemize
qemu-img convert -O formatoImmagineDesiderato nomeImmagineOriginale nomeImmagine
Convertita
\end_layout

\begin_layout Standard
ad esempio:
\end_layout

\begin_layout Itemize
qemu-img convert -O qcow2 test.vmdk test.qcow2 //in questo caso convertiamo
 l'immagine di tipo vmdk in qcow2
\end_layout

\begin_layout Itemize
qemu-img convert -O vdi test.qcow2 test.vdi //in questo caso un'immagine qcow2
 viene convertita in 
\begin_inset Quotes eld
\end_inset

vdi
\begin_inset Quotes erd
\end_inset

 che è un formato leggibile da virtualbox
\end_layout

\begin_layout Subsubsection
Console di Qemu
\end_layout

\begin_layout Standard
Qemu presenta una console molto utile per effettuare diverse operazioni,
 la console è accessibile tramite i tasti 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+Shift+2
\begin_inset Quotes erd
\end_inset

 e con 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+Shift+1
\begin_inset Quotes erd
\end_inset

 ritorniamo alla macchina virtuale di nuovo, la console ci permette di effettuar
e diverse operazioni, ad esempio possiamo reperire molte informazioni attraverso
 il comando:
\end_layout

\begin_layout Itemize
info opzione //dove la lista delle opzioni è reperibile attraverso il comando
 
\begin_inset Quotes eld
\end_inset

help info
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
ad esempio per vedere se il supporto kvm è abilitato possiamo eseguire:
\end_layout

\begin_layout Itemize
info kvm
\end_layout

\begin_layout Standard
altri comandi utili sono:
\end_layout

\begin_layout Itemize
info snapshots //mostra informazioni sugli snapshot
\end_layout

\begin_layout Standard
altre operazioni interessanti sono:
\end_layout

\begin_layout Itemize
screendump filename //esegue uno screenshot della macchina virtuale
\end_layout

\begin_layout Itemize
sendkey ctrl-alt-f1 //invia la sequenza specificata alla macchina virtuale,
 altri tasti degni di nota sono :shift, shift_r, altgr, esc, tab, backspace,
 ctrl_r, delete, menu
\end_layout

\begin_layout Itemize
system_powerdown //esegue uno shutdown, mandando un segnale ACPI, quindi
 il sistema si spegnerà safely
\end_layout

\begin_layout Itemize
balloon value //cambia la quantità di RAM, il valore 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 è il valore in MB di ram da impostare
\end_layout

\begin_layout Itemize
quit //esce dalla Macchina virtuale immediatamente
\end_layout

\begin_layout Itemize
system_reset //analogo ad un tasto di reset su una macchina fisica
\end_layout

\begin_layout Standard
Nota Bene: In the virtual consoles, you can use Ctrl-Up, Ctrl-Down, Ctrl-PageUp
 and Ctrl-PageDown to move in the back log.
\end_layout

\begin_layout Standard
AGGIUNGERE:
\end_layout

\begin_layout Itemize
aggiungere device usb
\end_layout

\begin_layout Subsubsection
Comandi Tastiera per Qemu (i.e., Qemu Keys)
\end_layout

\begin_layout Standard
During the graphical emulation, you can use special key combinations to
 change modes.
 The default key mappings are shown below, but if you use -alt-grab then
 the modifier is Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use -ctrl-grab
 then the modifier is the right Ctrl key (instead of Ctrl-Alt):
\end_layout

\begin_layout Itemize
Ctrl-Alt-f //Toggle full screen 
\end_layout

\begin_layout Itemize
Ctrl-Alt-+ //Enlarge the screen
\end_layout

\begin_layout Itemize
Ctrl-Alt– //Shrink the screen
\end_layout

\begin_layout Itemize
Ctrl-Alt-u //Restore the screen’s un-scaled dimensions 
\end_layout

\begin_layout Itemize
Ctrl-Alt-n //Switch to virtual console ’n’.
 Standard console mappings are:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
1 Target system display 
\end_layout

\begin_layout Itemize
2 Monitor 
\end_layout

\begin_layout Itemize
3 Serial port 
\end_layout

\end_deeper
\begin_layout Itemize
Ctrl-Alt //Toggle mouse and keyboard grab 
\end_layout

\begin_layout Standard
During emulation, if you are using the -nographic option, use :
\end_layout

\begin_layout Itemize
Ctrl-a h to get terminal commands:
\end_layout

\begin_layout Itemize
Ctrl-a h Ctrl-a ? //Print this help 
\end_layout

\begin_layout Itemize
Ctrl-a x //Exit emulator 
\end_layout

\begin_layout Itemize
Ctrl-a s //Save disk data back to file (if -snapshot) 
\end_layout

\begin_layout Itemize
Ctrl-a t //Toggle console timestamps 
\end_layout

\begin_layout Itemize
Ctrl-a b //Send break (magic sysrq in Linux) 
\end_layout

\begin_layout Itemize
Ctrl-a c //Switch between console and monitor 
\end_layout

\begin_layout Itemize
Ctrl-a Ctrl-a //Send Ctrl-a 
\end_layout

\begin_layout Subsubsection
Gestione Snapshot in Qemu
\end_layout

\begin_layout Standard
Per creare una copia di un'immagine virtuale che non influisce sulla copia
 originale eseguiamo:
\end_layout

\begin_layout Itemize
qemu-img create -f qcow2 -b centos-cleaninstall.img snapshot.img //crea un'immagin
e chiamata snapshot.img che è una copia dell'immagine chiamata centos-cleaninstal
l, il vantaggio rispetto ad una semplice copia è che utilizza una tecnologia
 chiamata Redirect-On-Write, quando l'immagine originale verrà cambiata
 allora lo snapshot sarà inutilizzabile
\end_layout

\begin_layout Standard
Da una macchina virtuale in running possiamo aprire il terminale di Qemu
 con 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+2
\begin_inset Quotes erd
\end_inset

 ed eseguire:
\end_layout

\begin_layout Itemize
savevm nomeSnapshot //salva la macchina virtuale con il nome snapshot
\end_layout

\begin_layout Itemize
info snapshot //visualizza gli snapshot disponibili, ogni snapshot è identificat
o da un id numerico ed un nome
\end_layout

\begin_layout Itemize
loadvm idSnapshotONomeSnapshot //carica lo snapshot menzionato
\end_layout

\begin_layout Itemize
delvm idSnapshotONomeSnapshot //cancella lo snapshot menzionato
\end_layout

\begin_layout Itemize
stop //Suspend execution of VM
\end_layout

\begin_layout Itemize
cont //Reverse a previous stop command - resume execution of VM
\end_layout

\begin_layout Subsubsection
Boot diretto di kernel
\end_layout

\begin_layout Standard
E' possibile effettuare boot diretti di kernel, ad esempio per motivi di
 testing/debugging, vediamo un esempio, per effettuare un boot diretto di
 un kernel linux effettuiamo:
\end_layout

\begin_layout Itemize
qemu-system-i386 -kernel arch/i386/boot/bzImage -hda root-2.4.20.img -append
 "root=/dev/hda" //usiamo l'opzione 
\begin_inset Quotes eld
\end_inset

-kernel
\begin_inset Quotes erd
\end_inset

 per lanciare il kernel menzionato, l'opzione 
\begin_inset Quotes eld
\end_inset

-append
\begin_inset Quotes erd
\end_inset

 serve a fornire opzioni al lancio del kernel è analogo ai parametri che
 passiamo ad un boot manager quando lancia un kernel, è obbligatorio fornire
 comunque un hard disk virtuale, per fare in modo che il kernel parta, in
 quanto il suo boot sector è utilizzato per lanciare il kernel linux
\end_layout

\begin_layout Standard
L'opzione 
\begin_inset Quotes eld
\end_inset

-initrd
\begin_inset Quotes erd
\end_inset

 può essere usato per fornire un immagine INITRD (o INITRAMFS), ad esempio:
\end_layout

\begin_layout Standard
Per eseguire banalmente un kernel custom non necessariamente Linux eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-i386 -kernel vmlinuz -initrd initrd.img -hda root-2.4.20.img -append
 "root=/dev/hda" //usiamo l'opzione 
\begin_inset Quotes eld
\end_inset

-kernel
\begin_inset Quotes erd
\end_inset

 per lanciare il kernel menzionato, l'opzione 
\begin_inset Quotes eld
\end_inset

-append
\begin_inset Quotes erd
\end_inset

 serve a fornire opzioni al lancio del kernel è analogo ai parametri che
 passiamo ad un boot manager quando lancia un kernel, è obbligatorio fornire
 comunque un hard disk virtuale, per fare in modo che il kernel parta, in
 quanto il suo boot sector è utilizzato per lanciare il kernel linux
\end_layout

\begin_layout Itemize
qemu-system-i386 -kernel myKernel.bin //viene eseguito il kernel menzionato,
 ovviamente al posto di 
\begin_inset Quotes eld
\end_inset

-i386
\begin_inset Quotes erd
\end_inset

 dobbiamo mettere l'architettura adatta al kernel
\end_layout

\begin_layout Subsubsection
Selezione del firmware (Legacy BIOS o UEFI)
\end_layout

\begin_layout Standard
Di default qemu caricherà un'interfaccia firmware di tipo Legacy BIOS, possiamo
 comunque decidere quale interfaccia firmware utilizzare attraverso l'opzione
 
\begin_inset Quotes eld
\end_inset

-bios
\begin_inset Quotes erd
\end_inset

, quest'opzione si rivela particolarmente utile nel momento in cui vogliamo
 emulare sistemi UEFI nel caso più comune, o comunque sistemi con interfaccia
 firmware totalmente diversa, pensato per altre piattaforme, il firmwareUEFI
 è emulabile attraverso il pacchetto 
\begin_inset Quotes eld
\end_inset

ovmf
\begin_inset Quotes erd
\end_inset

, quindi è necessario installare questo pacchetto o scaricare comunque il
 file relativo del firmware da internet, una volta ottenuto questo firmware
 eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -bios OVMF.fd -hda disk.img -cdrom GNULinux.iso -boot d
 //esegue l'immagine di un sistema operativo avviandolo in modalità UEFI,
 cioè attraverso un interfaccia firmare di tipo UEFI
\end_layout

\begin_layout Subsubsection
Dispositivi USB in Qemu
\end_layout

\begin_layout Standard
Possiamo rendere disponibile un dispositivo USB identificato attraverso
 un 
\begin_inset Quotes eld
\end_inset

lsusb
\begin_inset Quotes erd
\end_inset

 sul sistema host, andando a specificare il 
\begin_inset Quotes eld
\end_inset

Bus
\begin_inset Quotes erd
\end_inset

 attraverso 
\begin_inset Quotes eld
\end_inset

hostbus
\begin_inset Quotes erd
\end_inset

 e l'
\begin_inset Quotes erd
\end_inset

ID
\begin_inset Quotes erd
\end_inset

 con 
\begin_inset Quotes eld
\end_inset

hostaddr
\begin_inset Quotes erd
\end_inset

, facendo:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -m 1024 -name debianProva miaImg -usb -device usb-host,hostbu
s=2,hostaddr=13
\end_layout

\begin_layout Standard
Potrebbe essere necessario aggiungere i diritti di scrittura al device per
 poterlo utilizzare, una delle soluzioni è scrivere una semplice udev rule,
 che tenga conto del device.
\end_layout

\begin_layout Subsubsection
Scheda Audio in Qemu
\end_layout

\begin_layout Standard
Per montare una scheda audio nel nostro sistema possiamo utilizzare l'opzione
 
\begin_inset Quotes eld
\end_inset

-soundhw
\begin_inset Quotes erd
\end_inset

, per vedere quali schede video abbiamo a disposizione possiamo eseguire:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -soundhw ? //visualizza le schede audio disponibili
\end_layout

\begin_layout Standard
per avviare qemu con una scheda audio, ad esempio una Intel HD Audio (hda),
 allora eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2G -hda w7img.img -soundhw hda //avvia
 l'immagine di un sistema operativo con una scheda audio Intel HD Audio
\end_layout

\begin_layout Standard
per avviare qemu con sia scheda audio che un dispositivo usb eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2G -hda w7img.img -soundhw hda -usb -device
 usb-host,hostbus=2,hostaddr=13 //esegue qemu con sia scheda audio che dispositi
vo usb
\end_layout

\begin_layout Subsubsection
Schede Video in Qemu
\end_layout

\begin_layout Standard
Per montare una scheda video diversa da quella di default (cirrus), possiamo
 visualizzare la lista delle disponibili eseguendo 
\begin_inset Quotes eld
\end_inset

man qemu-system-86_64
\begin_inset Quotes erd
\end_inset

 e poi premiamo 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 per cercare e inseriamo la stringa 
\begin_inset Quotes eld
\end_inset

-vga
\begin_inset Quotes erd
\end_inset

, come possiamo vedere abbiamo diverse opzioni, vediamo un esempio di impostazio
ne di scheda video:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2G -hda w7img.img -vga qxl //in questo
 caso imponiamo l'utilizzo di una scheda video qxl, questo tipo di scheda
 video è utile ad esempio su macchine virtuali GNU/Linux con alcune distro
\end_layout

\begin_layout Subsubsection
Altre Periferiche in Qemu
\end_layout

\begin_layout Standard
Per vedere quali device abbiamo a disposizione per una determinata architettura
 possiamo eseguire:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -device ? //dove al posto di 
\begin_inset Quotes eld
\end_inset

qemu-system-x86_64
\begin_inset Quotes erd
\end_inset

 possiamo mettere l'architettura che preferiamo
\end_layout

\begin_layout Subsubsection
Redirection di porte per collegamenti
\end_layout

\begin_layout Standard
Vediamo ora come è possibile redirigere porte per avere collegamenti tra
 host e guest machine, ad esempio potremo collegarci attraverso ssh, o sftp
 o attraverso qualsiasi metodo noi desideriamo, in pratica è doveroso sapere
 che qemu crea una rete virtuale in cui sono presenti solo macchina host
 che funge anche da server dhcp eccetera con IP di default 10.0.2.2, e macchina
 guest con IP di default 10.0.2.15, a questo punto se vogliamo ad esempio effettuar
e un collegamento tra host e guest, dobbiamo redirigere il traffico della
 macchina host di una porta a nostra scelta sulla porta su cui si aspetta
 la connessione il sistema guest.
 Ad esempio, vogliamo effettuare una connessione ssh tra host e guest, e
 sappiamo che il guest si aspetta una connessione su porta 22, allora noi
 lanceremo qemu redirigendo il traffico della porta 5555 (scelta a caso
 da noi) al sistema guest sulla porta 22 con:
\end_layout

\begin_layout Itemize
qemu.system-x86_64 -enable-kvm -hda miaImg.img -m 2G -smp 2 -redir tcp:5555::22
 //in questo caso redirigiamo tutto il traffico tcp che avviene in localhost
 sulla porta 5555 alla porta 22 dell'host, al posto di 
\begin_inset Quotes eld
\end_inset

tcp
\begin_inset Quotes erd
\end_inset

 possiamo inserire 
\begin_inset Quotes eld
\end_inset

udp
\begin_inset Quotes erd
\end_inset

 se è questo il protocollo interessato
\end_layout

\begin_layout Standard
ad esempio nel caso di una connessione netcat eseguiremo
\end_layout

\begin_layout Itemize
ncat localhost 5555
\end_layout

\begin_layout Standard
una volta lanciato il sistema guest, ora possiamo da host effettuare:
\end_layout

\begin_layout Itemize
ssh nomeAccountValidoGuest@localhost -p 5555 //in questo caso ci connettiamo
 alla macchina guest dalla macchina host, per la macchina guest sarà una
 normale connessione in ssh alla porta 22
\end_layout

\begin_layout Standard
se invece volessimo collegarci dal sistema guest al sistema host eseguiamo
 dal sistema guest:
\end_layout

\begin_layout Itemize
ssh nomeAccountValidoHost@10.0.2.2 -p 22 //richiediamo una connessione alla
 porta 22
\end_layout

\begin_layout Standard
possiamo sempre verificare l'indirizzo ip del sistema host, eseguendo un
 comando come:
\end_layout

\begin_layout Itemize
route -n //visualizza l'indirizzo ip del sistema host sotto la voce 
\begin_inset Quotes eld
\end_inset

Gateway
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Qemu Redirection
\end_layout

\begin_layout Paragraph
Qemu Monitor Redirection
\end_layout

\begin_layout Standard
Possiamo avere il monitor di qemu sul terminale in cui l'abbiamo lanciato
 attraverso l'opzione 
\begin_inset Quotes eld
\end_inset

monitor -stdio
\begin_inset Quotes erd
\end_inset

, in pratica il monitor di qemu che prima aprivamo con la combinazione 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+2
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -hda VMs/debian.img -monitor stdio //avvia
 una macchina virtuale, e apre il monitor di qemu direttamente nel terminale
 da cui ho avviato qemu, quindi non dovrò premere 
\begin_inset Quotes eld
\end_inset

Ctrl+Alt+2
\begin_inset Quotes erd
\end_inset

 per accedere al terminale di qemu
\end_layout

\begin_layout Paragraph*
Qemu Text Redirection
\end_layout

\begin_layout Standard
Possiamo anche redirigere il testo all'interno del nostro terminale attraverso
 il comando:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2048 -smp 2 -hda VMs/lfs.img -kernel /boot/vmli
nuz-3.2.0-4-686-pae -append /boot/initrd.img "root=/dev/sda2 console=tty0 console=t
tyS0 rw" -serial mon:stdio
\end_layout

\begin_layout Standard
oppure addirittura non aprire una finestra per qemu, andando a redirigere
 tutto il testo all'interno del terminale, eseguiamo:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2048 -smp 2 -hda VMs/lfs.img -kernel /boot/vmli
nuz-3.2.0-4-686-pae -append /boot/initrd.img "root=/dev/sda2 console=tty0 console=t
tyS0 rw" -serial mon:stdio -nographic //l'opzione 
\begin_inset Quotes eld
\end_inset

-nographic
\begin_inset Quotes erd
\end_inset

 fa in modo di non creare una nuova finestra per qemu e redirige tutto all'inter
no del terminale da cui ho lanciato qemu
\end_layout

\begin_layout Standard
nel caso volessimo redirigere tutto il testo all'interno della nostra finestra
 terminale, ma anzichè dargli in input un kernel, dandogli in pasto solo
 un'immagine da cui parte un sistema operativo, dobbiamo in pratica impostare
 le opzioni di boot all'interno del sistema operativo questo è possibile
 andando a modificare il file /etc/default/grub ed andando ad aggiungere
 la stringa:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0 rw"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
una volta apportata questa modifica possiamo eseguire:
\end_layout

\begin_layout Itemize
qemu-system-x86_64 -enable-kvm -m 2048 -smp 2 -hda VMs/debian.img -serial
 mon:stdio -nographic //l'opzione 
\begin_inset Quotes eld
\end_inset

-nographic
\begin_inset Quotes erd
\end_inset

 fa in modo di non creare una nuova finestra per qemu e redirige tutto all'inter
no del terminale da cui ho lanciato qemu
\end_layout

\begin_layout Standard
Questa tecnica mi è tornata molto utile nel kernel development, in quanto
 non ho tutto l'overhead portato da spice, per il copy & paste, ovviamente
 non potrò avviare il server xorg, per effettuare copy & paste dall'interfaccia
 grafica ho infatti bisogno di spice.
\end_layout

\begin_layout Subsubsection
Initramfs e Qemu sono amici
\end_layout

\begin_layout Standard
E' molto comodo per qemu quando si vuole lanciare un kernel, e un disco,
 utilizzare al posto di un'immagine disco solo un initramfs, in modo da
 avere più flessibilità, l'initramfs avrà uno script chiamato 
\begin_inset Quotes eld
\end_inset

/init
\begin_inset Quotes erd
\end_inset

 che eseguirà tutte le inizializzazioni o in genere le operazioni da effettuare;
 ad esempio per emulare sistemi arm, una volta creato un initramfs possiamo
 eseguire:
\end_layout

\begin_layout Itemize
QEMU_AUDIO_DRV=none 
\backslash
 qemu-system-arm -m 256M -nographic -M vexpress-a9 -kernel zImage -append
 "console=ttyAMA0 rdinit=/bin/sh" -dtb vexpress-v2p-ca9.dtb -initrd initramfs.cpio.
gz
\end_layout

\begin_layout Section
Docker
\end_layout

\begin_layout Standard
Docker is a Container managing software.
 Containers or in general Container based virtualization uses the kernel
 on the host's OS to tun multiple guest istances.
 Each guest istance is called a container, and each container has its own:
\end_layout

\begin_layout Itemize
root fs
\end_layout

\begin_layout Itemize
processes
\end_layout

\begin_layout Itemize
memory
\end_layout

\begin_layout Itemize
devices
\end_layout

\begin_layout Itemize
network ports
\end_layout

\begin_layout Standard
An example is for example even if we have to run multiple versions of java
 for different applications, each one using a different virtual machine.
\end_layout

\begin_layout Standard
The advantages of using Containers vs VMs are:
\end_layout

\begin_layout Itemize
containers are more lightweight
\end_layout

\begin_layout Itemize
no need to install guest OS
\end_layout

\begin_layout Itemize
less cpu, ram, storage space required
\end_layout

\begin_layout Itemize
more containers per machine than VMs
\end_layout

\begin_layout Itemize
greater protability
\end_layout

\begin_layout Subsection
Docker Installation
\end_layout

\begin_layout Standard
Docker engine is the program that enables containers to be built, shipped
 and run, docker engine uses Linux kernel namespaces and control groups,
 namespaces give us the isolated workspace.
 Una volta installato e avviato il demone, con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> systemctl start docker
\end_layout

\end_inset


\end_layout

\begin_layout Standard
oppure se non abbiamo il demone possiamo avviare l'applicazione con 
\begin_inset Quotes eld
\end_inset

sudo docker -d &
\begin_inset Quotes erd
\end_inset

 questa è la modalità demone.
\end_layout

\begin_layout Standard
Possiamo provarne il funzionamento andando ad avviare:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> sudo docker run hello-world
\end_layout

\end_inset


\end_layout

\begin_layout Standard
questa istruzione dovrebbe dirci che l'immagine hello world non esiste,
 abbiamo dovuto usare sudo, per poter avviare docker con altri utenti dobbiamo
 aggiungerli al gruppo docker, con:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> sudo usermod -aG docker giuseppe
\end_layout

\end_inset


\end_layout

\begin_layout Standard
now we logout and relogin, in order make the changes take effect.
\end_layout

\begin_layout Standard
To look at the docker version we do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker version
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Images vs Containers
\end_layout

\begin_layout Standard
Images:
\end_layout

\begin_layout Itemize
read only template used to create containers
\end_layout

\begin_layout Itemize
built by me or other docker users
\end_layout

\begin_layout Itemize
stored in the docker hub or my local registry
\end_layout

\begin_layout Standard
Containers:
\end_layout

\begin_layout Itemize
isolated application platform
\end_layout

\begin_layout Itemize
contains everything needed to run my app
\end_layout

\begin_layout Itemize
based on one or more images
\end_layout

\begin_layout Standard
we can browse images on dockerhub, and the one called 
\begin_inset Quotes eld
\end_inset

library/java
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

library/nginx
\begin_inset Quotes erd
\end_inset

, so in general starting with 
\begin_inset Quotes eld
\end_inset

library/
\begin_inset Quotes erd
\end_inset

 are the official ones.
\end_layout

\begin_layout Standard
Now it is important to define the difference between an image and a live
 container.
\end_layout

\begin_layout Itemize
An image: is a snapshot which does not change unless we do a commit, in
 order to instantiate an image we can do a 
\begin_inset Quotes eld
\end_inset

docker run
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
A container is a living image, what we do here is persistent, and we can
 have more containers which were originated from the same image
\end_layout

\begin_layout Subsubsection
Display local images
\end_layout

\begin_layout Standard
To display local images we can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker images //displays docker images
\end_layout

\end_inset


\end_layout

\begin_layout Standard
notice that each docker image has 
\begin_inset Quotes eld
\end_inset

tags
\begin_inset Quotes erd
\end_inset

 associated to it, these tags represent the actual version, for example
 for java we could have tags like 
\begin_inset Quotes eld
\end_inset

6-jre, 6-jdk, latest, 6b32, etc...
\begin_inset Quotes erd
\end_inset

 so tags refer to various versions, the default tag is 
\begin_inset Quotes eld
\end_inset

latest
\begin_inset Quotes erd
\end_inset

.
 So images are specified by 
\begin_inset Quotes eld
\end_inset

image:tag
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Containers can be specified using their ID or name, there are:
\end_layout

\begin_layout Itemize
long ID
\end_layout

\begin_layout Itemize
short ID
\end_layout

\begin_layout Standard
short ID and name of running containers can be obtained using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker ps
\end_layout

\end_inset


\end_layout

\begin_layout Standard
while long ID are obtained by inspecting the container.
\end_layout

\begin_layout Standard
To display all the available containers we can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker ps -a
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Creating a Container
\end_layout

\begin_layout Standard
To create a container we do:
\end_layout

\begin_layout Itemize
sudo docker run [options] [image] [command] [args]
\end_layout

\begin_layout Standard
so docker will create the image if it doesn't exist and execute the eventual
 command (if specified), so for example we could do:
\end_layout

\begin_layout Itemize
docker run ubuntu:14.04 echo 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Itemize
docker run ubuntu:14.04 ps -aux
\end_layout

\begin_layout Standard
notice that docker run = docker create + docker start, hence any time we
 do a docker run, a new container is created, in order to have persistance
 among states, we should launch docker with start and attack
\end_layout

\begin_layout Subsubsection
Connecting to the Container
\end_layout

\begin_layout Standard
To instantiate an image and connect directly to the container with a shell
 we do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker run -i -t ubuntu:latest /bin/bash 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in this case the 
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 flag tells docker to connect to the STDIN on the container, and the flag
 
\begin_inset Quotes eld
\end_inset

-t
\begin_inset Quotes erd
\end_inset

 flag specifies to get a pseudo-terminal.
 We MUST remember that the docker container is alive only when the process
 is alive and changes are not written by default, so we can do whatever
 we want and changes will not be done to our image.
 Anyway changes will continue to live in the container.
 We can view it with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker ps -a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and we can connect back to it with:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker start <id>
\end_layout

\begin_layout Plain Layout

$> docker attach <id>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or more simply:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$> docker start -ia <id>
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Docker Detached Mode
\end_layout

\begin_layout Standard
Now we do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker run -d centos:7 ping 127.0.0.1 -c 100
\end_layout

\end_inset

 in this case the docker process detaches itself from the current shell,
 so the operation specified is acting in the background, and only an ID
 is given to us, we can view it with 
\begin_inset Quotes eld
\end_inset

docker ps
\begin_inset Quotes erd
\end_inset

, viewing even the short ID, now with the short ID we can see what's printing
 on the standard output our process, with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker logs 62ba075bee18
\end_layout

\end_inset

 in this case we see the ping output, since it was the command we gave.
 
\end_layout

\begin_layout Standard
We can even attach ourself to the log file with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker logs -f 62ba075bee18
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in this case we see the stdout in real time.
\end_layout

\begin_layout Subsubsection
Practical Example: A Web Application Container
\end_layout

\begin_layout Standard
Now we want to run a web application inside a container, we'll use the 
\begin_inset Quotes eld
\end_inset

-P
\begin_inset Quotes erd
\end_inset

 flag to map contiainer ports to host ports, so we do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker run -d -P tomcat:latest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
now we can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker ps
\end_layout

\end_inset

 here we see the short ID of our applications and the portsgiven to our
 system, indeed we'll see a string under 
\begin_inset Quotes eld
\end_inset

PORTS
\begin_inset Quotes erd
\end_inset

 with for example: 
\begin_inset Quotes eld
\end_inset

0.0.0.0:49153->8080/tcp
\begin_inset Quotes erd
\end_inset

 this means that the port 8080 of the container has been mapped to the port
 49153 on the host system.
\end_layout

\begin_layout Standard
To kill an existing docker process, once we have seen its ID, we can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker kill 62ba075bee18
\end_layout

\end_inset


\end_layout

\begin_layout Standard
now if we do something, like creating a new file or modifying an existing
 file, we can exit, and once we exit in order to get back we should launch
 docker with start and attach
\end_layout

\begin_layout Subsubsection
Practical Example: Giving Graphics (Xorg) and Sound to an application
\end_layout

\begin_layout Standard
Before giving sound and video to a container, we have to enable the host
 machine to accept connections to the Xorg display from the containers,
 we can do this by typing (before starting the docker container):
\end_layout

\begin_layout Itemize
xhost local:localuser 
\end_layout

\begin_layout Itemize
xhost + //it is an alternative to the previous command, allowing everyone
 to connect to the Xorg server
\end_layout

\begin_layout Standard
it's useful to put this in an initialization configuration file, such as
 
\begin_inset Quotes eld
\end_inset

/etc/profile
\begin_inset Quotes erd
\end_inset

 or things of this kind.
 
\end_layout

\begin_layout Standard
Once we have done this, the following command let us run graphical and/or
 audio application from inside the container:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker run 
\backslash

\end_layout

\begin_layout Plain Layout

-v /tmp/.X11-unix:/tmp/.X11-unix 
\backslash
 # mount the X11 socket 
\end_layout

\begin_layout Plain Layout

-e DISPLAY=unix$DISPLAY 
\backslash
 # pass the display called unix0
\end_layout

\begin_layout Plain Layout

--device /dev/snd 
\backslash
 # sound
\end_layout

\end_inset


\end_layout

\begin_layout Standard
let's see an analogous example in which I ran a kali linux distro docker
 image:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker run -it --device /dev/snd -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix$
DISPLAY kalilinux/kali-linux-docker /bin/bash
\end_layout

\end_inset


\end_layout

\begin_layout Standard
so we just have to remember that each time we have to run a graphical applicatio
n we must provide:
\end_layout

\begin_layout Itemize
necessary directories (-v)
\end_layout

\begin_layout Itemize
necessary devices (–device)
\end_layout

\begin_layout Itemize
necessary environment variables (-e)
\end_layout

\begin_layout Standard
notice that on SELinux (e.g., Fedora and friends), systems there are additional
 policies that have to be respected, in order to bypass them temporarily
 we just have to run:
\end_layout

\begin_layout Itemize
su -c "setenforce 0"
\end_layout

\begin_layout Standard
this is unsafe, to ensure safeness, look at SELinux, and how to add/modify
 policies, probably a command like:
\end_layout

\begin_layout Itemize
chcon -Rt svirt_sandbox_file_t /path/to/volume //check command
\end_layout

\begin_layout Subsection
Image Layers
\end_layout

\begin_layout Standard
Images are comprised of multiple layers, a layer is also just another image,
 but everyimage contains a base layer, layers are read only.
 When we launch a container, docker creates a top writable layer for containers,
 parent images are read only, so all changes are made at the writeable layer.
 To save changes in a container as a new image we do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker commit [options] [container ID] [repository:tag]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
repository name should be based on username/application, we can reference
 the container with the container name instead of ID, let's see an example,
 we can do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

docker commit 984d25f537c5 johnnyty/myapplycation:1.0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
if we don't specify the tag, docker uses the default one 
\begin_inset Quotes eld
\end_inset

latest
\begin_inset Quotes erd
\end_inset

.
 Let's see a scenario, so we do:
\end_layout

\begin_layout Itemize
docker run -it ubuntu:15.05 bash
\end_layout

\begin_layout Standard
then we do:
\end_layout

\begin_layout Itemize
sudo apt install curl
\end_layout

\begin_layout Standard
now we can exit the docker image, and see its ID with:
\end_layout

\begin_layout Itemize
docker ps -a //view docker ID of the exited docker image we want to save
 the state
\end_layout

\begin_layout Standard
from here we copy its short ID and do:
\end_layout

\begin_layout Itemize
docker commit 984d25f537c5 johnnyty/myapp:1.0 //here the code is the short
 ID
\end_layout

\begin_layout Standard
now we can run 
\end_layout

\begin_layout Itemize
docker images //this will let us view the last created image
\end_layout

\begin_layout Standard
and now we can run our image as we did before but with the new name, so
 with:
\end_layout

\begin_layout Itemize
docker run -it johnnyty/myapp:1.0
\end_layout

\begin_layout Subsection
Dockerfile
\end_layout

\begin_layout Standard
A dockerfile is a configuration file that contains instructions for buildinf
 a Docker image.
 Basically we have:
\end_layout

\begin_layout Itemize
FROM instructions: who specify the base image to use, such as:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
FROM ubuntu:14.04
\end_layout

\end_deeper
\begin_layout Itemize
RUN instructions: who specify commands to execute, such as:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
RUN apt-get install vim
\end_layout

\begin_layout Itemize
RUN apt-get install curl
\end_layout

\end_deeper
\begin_layout Standard
so an example dockerfile can be built as the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Example of a comment
\end_layout

\begin_layout Plain Layout

FROM ubuntu:14.04
\end_layout

\begin_layout Plain Layout

RUN apt-get install vim
\end_layout

\begin_layout Plain Layout

RUN apt-get install curl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the fact is that if we have 10 RUN instructions we do 10 commits, to avoid
 this we can use the 
\begin_inset Quotes eld
\end_inset

&&
\begin_inset Quotes erd
\end_inset

 shell operator to aggregate RUN instructions together, so we can build
 dockerfile with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FROM ubuntu:14.04
\end_layout

\begin_layout Plain Layout

RUN apt-get update && apt-get install -y 
\backslash

\end_layout

\begin_layout Plain Layout

	curl 
\backslash

\end_layout

\begin_layout Plain Layout

	vim 
\backslash

\end_layout

\begin_layout Plain Layout

	openjdk-7-jdk
\end_layout

\end_inset


\end_layout

\begin_layout Standard
now to build an image following this dockerfile we do:
\end_layout

\begin_layout Itemize
docker build -t myrepo/myapp:1.0 path/to/folder/containing/theDockerfile
\end_layout

\begin_layout Standard
let's see another example:
\end_layout

\begin_layout Itemize
docker build -t myrepo2/mywebapp:latest .
 //the build context here is the current directory
\end_layout

\begin_layout Standard
Notice that the dockerfile should be named 
\begin_inset Quotes eld
\end_inset

Dockerfile
\begin_inset Quotes erd
\end_inset

, we can even choose another name, but in this case we should mention the
 filename with the flag 
\begin_inset Quotes eld
\end_inset

-f
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In the Dockerfiles we can even specify commands that should be executed
 once the container is executed, this is done through the 
\begin_inset Quotes eld
\end_inset

CMD
\begin_inset Quotes erd
\end_inset

 directive, let's see an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FROM ubuntu:14.04
\end_layout

\begin_layout Plain Layout

RUN apt-get update && apt-get install -y 
\backslash

\end_layout

\begin_layout Plain Layout

	curl 
\backslash

\end_layout

\begin_layout Plain Layout

	vim
\end_layout

\begin_layout Plain Layout

CMD ping -c 10 127.0.0.1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
these commands anyway can be overridden by specifying a command in docker
 run, as we did in the first examples.
\end_layout

\begin_layout Standard
We can even specify the 
\begin_inset Quotes eld
\end_inset

ENTRYPOINT
\begin_inset Quotes erd
\end_inset

 directive which executes the image as an executable for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ENTRYPOINT ["ping"]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
once we have put this at the end of our Dockerfile, when we run the docker
 image the commands do not override the ping command specified, instead
 they are taken as argument, this docker image acts exactly like an executable.
\end_layout

\begin_layout Subsubsection
Start and Stop Containers or exec other processes
\end_layout

\begin_layout Standard
We can list all containers with:
\end_layout

\begin_layout Itemize
docker ps -a
\end_layout

\begin_layout Standard
now we can start a container in background as nginx with:
\end_layout

\begin_layout Itemize
docker run -d nginx
\end_layout

\begin_layout Standard
we can stop this container with:
\end_layout

\begin_layout Itemize
docker stop <containerIDviewedWithPs-a>
\end_layout

\begin_layout Standard
we can resume the container with:
\end_layout

\begin_layout Itemize
docker start <containerIDviewedWithPs-a>
\end_layout

\begin_layout Standard
To start other processes within the same container (assuming the container
 has already started) we can do:
\end_layout

\begin_layout Itemize
docker exec -i -t <containerID> /bin/bash //this opens another shell on
 the container
\end_layout

\begin_layout Standard
In order to create a container we can do:
\end_layout

\begin_layout Itemize
docker create //creates a writeable container from the image and prepares
 it for running.
\end_layout

\begin_layout Itemize
docker run //creates the container (same as docker create) and runs it.
 
\end_layout

\begin_layout Subsubsection
Practical example: Tomcat
\end_layout

\begin_layout Standard
We can do:
\end_layout

\begin_layout Itemize
docker run -d tomcat:7 //this starts (and downloads if it doesn't exist)
 an image of tomcat version 7 in background
\end_layout

\begin_layout Standard
then
\end_layout

\begin_layout Itemize
docker ps //here we see the short ID of the tomcat image
\end_layout

\begin_layout Standard
now we can attach to the container with another process by doing:
\end_layout

\begin_layout Itemize
docker exec -it <containerID> /bin/bash //this starts a shell on the container
\end_layout

\begin_layout Standard
now here for example we can run:
\end_layout

\begin_layout Itemize
ps -ef //shows the active processes inside the container, here we'll see
 all the processes attached to the container
\end_layout

\begin_layout Standard
from here if we execute:
\end_layout

\begin_layout Itemize
exit
\end_layout

\begin_layout Standard
we won't close the container since the bash was not the process with PID
 1, which it was actually the tomcat background initial execution.
\end_layout

\begin_layout Standard
Now in order to resume the image we can do:
\end_layout

\begin_layout Itemize
docker images
\end_layout

\begin_layout Itemize
docker start f357e2faab77 //restart it in the background
\end_layout

\begin_layout Itemize
docker attach f357e2faab77 //reattach the terminal & stdin
\end_layout

\begin_layout Standard
and we are back to our machine, we can also be faster and execute:
\end_layout

\begin_layout Itemize
docker start `docker ps -q -l`
\end_layout

\begin_layout Itemize
docker attach `docker ps -q -l`
\end_layout

\begin_layout Subsubsection
Delete Containers
\end_layout

\begin_layout Standard
To remove a container we first have to stop it and then run:
\end_layout

\begin_layout Itemize
docker rm <nameOfTheContainer>
\end_layout

\begin_layout Standard
or we can execute:
\end_layout

\begin_layout Itemize
docker rmi myrepo/myapp:1.0
\end_layout

\begin_layout Itemize
docker rmi -f myrepo/myapp:1.0 //in this case we delete the image in a forced
 way
\end_layout

\begin_layout Standard
we can verify the deletion of an image with:
\end_layout

\begin_layout Itemize
docker images
\end_layout

\begin_layout Subsubsection
Tagging Images
\end_layout

\begin_layout Standard
We can tag images or rename a local image repo with:
\end_layout

\begin_layout Itemize
docker tag imageID repo:tag
\end_layout

\begin_layout Standard
or:
\end_layout

\begin_layout Itemize
docker tag localRepo:tag anotherRepo:tag
\end_layout

\begin_layout Standard
for example:
\end_layout

\begin_layout Itemize
docker tag edfc1234je32 trainingteam/testexample:1.0
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Itemize
docker tag johnny/testimage:1.5 trainingteam/testexample
\end_layout

\begin_layout Subsubsection
Copying data into a Container
\end_layout

\begin_layout Standard
In order to copy data in a container we can do:
\end_layout

\begin_layout Itemize
docker cp /path/to/myfile.txt name_of_container:/dest/path
\end_layout

\begin_layout Itemize
docker cp name_of_container:/dest/path  /path/to/myfile.txt
\end_layout

\begin_layout Subsubsection
Pushing Image to Remote Repo
\end_layout

\begin_layout Standard
We can push an image with:
\end_layout

\begin_layout Itemize
docker push johnnytu/testimage:1.0 //this will begin the push once we specify
 the credentials
\end_layout

\begin_layout Standard
note that this psh will give us errors if on our account there isn't yet
 any repo called 
\begin_inset Quotes eld
\end_inset

johnnytu/testimage
\begin_inset Quotes erd
\end_inset

 so we first have to create it if it doesn't exist.
\end_layout

\begin_layout Subsection
Volumes
\end_layout

\begin_layout Standard
A volume is a designated directory in a container, which is designed to
 persist data, independent of the container's life cycle.
 These volumes:
\end_layout

\begin_layout Itemize
can be shared between containers
\end_layout

\begin_layout Itemize
can be mapped to a host directory
\end_layout

\begin_layout Itemize
persist when a container is deleted
\end_layout

\begin_layout Itemize
volume changes are excluded when updating an image
\end_layout

\begin_layout Standard
Volumes are mounted when creating or executing a container, volume path
 must be absolute, let's see some example:
\end_layout

\begin_layout Itemize
docker run -d -P -v /myvolume nginx:1.7 //in this case we mount the dir /myvolume
 into the filesystem of the specified image
\end_layout

\begin_layout Standard
or another interesting example is:
\end_layout

\begin_layout Itemize
docker run -it -v /data/src:/test/src nginx:1.7 //in this case we map the
 /data/src directory from the host into the /test/src directory in the container
\end_layout

\begin_layout Standard
We can specify volumes even into Dockerfiles, let's see some example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

VOLUME /myvol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or even multiple volumes like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

VOLUME /www/website1 /www/website2 /myvol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or with a JSON notation like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

VOLUME ["myvol", "myvol2"]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mounting folders from the host is food for testing purposes but generally
 not recommended for production use, indeed it is not possible to do the
 mappings inside the Dockerfiles.
\end_layout

\begin_layout Subsubsection
Mapping of ports and services
\end_layout

\begin_layout Standard
We don't always need mapping of ports, once we have runned our system it
 will have its IP address, let's say we have a shell, we can inspect the
 IP with the common command 
\begin_inset Quotes eld
\end_inset

ifconfig
\begin_inset Quotes erd
\end_inset

, once we have the IP address of the dockered machine, if we launch a service
 (e.g.
 apache) on the dockered machine we can find it at ip address: port, just
 like a machine which is in LAN.
 Notice that by default on most systems docker will configure the dockered
 machine inside a NATted network inside the host machine.
\end_layout

\begin_layout Standard
Ok, now let's see a scenario where we want to mirror/map a service on the
 host machine, like for example running apache on the guest dockered machine
 and running it like it was running on the host machine.
 Let's see an example of manual mapping of ports:
\end_layout

\begin_layout Itemize
docker run -d -p 8080:80 nginx:1.7 //maps port 80 on the container to port
 8080 on the host
\end_layout

\begin_layout Standard
instead if we would like to do the automatic mapping we do:
\end_layout

\begin_layout Itemize
docker run -d -P nginx:1.7 //this will do the automatic port mapping, but
 this only works for ports defined in the 
\begin_inset Quotes eld
\end_inset

EXPOSE
\begin_inset Quotes erd
\end_inset

 instructions inside the Dockerfile
\end_layout

\begin_layout Standard
indeed to let our image to support automatic port mappings we should add
 the ports to enable for automatic mappings in the Dockerfile:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

EXPOSE 80 443
\end_layout

\end_inset

 in this case we are enabling automatic mapping for port 80 and 443 (HTTP
 and HTTPS).
\end_layout

\begin_layout Subsubsection
Linking Containers
\end_layout

\begin_layout Standard
To create a link, we first have to create the source containeir and the
 create the recipient container and then use the 
\begin_inset Quotes eld
\end_inset

–link
\begin_inset Quotes erd
\end_inset

, let's see an example: (BEST PRACTICE: give the containers meaningful names)
\end_layout

\begin_layout Standard
We first create the source container using the postgres:
\end_layout

\begin_layout Itemize
docker run -d –name database postgres
\end_layout

\begin_layout Standard
then we create the recipient container and link it:
\end_layout

\begin_layout Itemize
docker run -d -P –name website –link database:db nginx:1.7 //here, after
 –link we put the name of the source folowed by its alias
\end_layout

\begin_layout Standard
let's see another example:
\end_layout

\begin_layout Itemize
docker run -d –name dbms postgres:latest
\end_layout

\begin_layout Itemize
docker run -it –name website –link dbms:db ubuntu:14.04 bash 
\end_layout

\begin_layout Standard
now inside our ubuntu container if we cat /etc/hosts, we can see clearly
 an entry for our alias name called 
\begin_inset Quotes eld
\end_inset

db
\begin_inset Quotes erd
\end_inset

 with its own IP address.
 
\end_layout

\begin_layout Standard
We could check this ip address even from outside the container with:
\end_layout

\begin_layout Itemize
docker inspect dbms | grep IPAddress
\end_layout

\begin_layout Standard
as we can see the two IPs will match.
\end_layout

\begin_layout Subsubsection
We can automate Build Repos!!
\end_layout

\begin_layout Standard
On dockerhub there is the possibility to automate the building of the repo,
 let's assume we have a java source called JavaHelloWorld.java, we then create
 a Dockerfile like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FROM java:7
\end_layout

\begin_layout Plain Layout

COPY JavaHelloWorld.java .
\end_layout

\begin_layout Plain Layout

RUN javac JavaHelloWorld.java
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CMD["java", "JavaHelloWorld"]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
now if we have configured our Dockerhub repo correctly when we commit and
 push from git to github or the configured git repo on Dockerhub Dockerhub
 will notice the commit and create a new Docker image.
 We can even download the image in a second moment with:
\end_layout

\begin_layout Itemize
docker pull myrepo/myjavapp
\end_layout

\begin_layout Standard
and then execute with:
\end_layout

\begin_layout Itemize
docker run myrepo/myjavapp
\end_layout

\begin_layout Standard
this will run my java application; if we change the code and commit+push
 with git a new image will automatically be created.
 This process is called 
\begin_inset Quotes eld
\end_inset

CI
\begin_inset Quotes erd
\end_inset

 (Continous Integration).
\end_layout

\begin_layout Subparagraph
Container Logging
\end_layout

\begin_layout Standard
We can show whatever PID 1 writes to stdout
\end_layout

\begin_layout Itemize
docker logs <containerName>
\end_layout

\begin_layout Standard
or we can view and follow the output with:
\end_layout

\begin_layout Itemize
docker logs -f <containerName>
\end_layout

\begin_layout Standard
for example we can start a container with tomcat with:
\end_layout

\begin_layout Itemize
docker run -d tomcat
\end_layout

\begin_layout Standard
then with
\end_layout

\begin_layout Itemize
docker ps 
\end_layout

\begin_layout Standard
we view the currently running containers with their name, now we can do:
\end_layout

\begin_layout Itemize
docker logs containerName //it opens the log for the process ID 1 of that
 container
\end_layout

\begin_layout Standard
we can follow the output with:
\end_layout

\begin_layout Itemize
docker logs -f containerName
\end_layout

\begin_layout Standard
we can even map a a directory on our host to the application log directory,
 so that we can see and operate locally on the container logs, for example
 with:
\end_layout

\begin_layout Itemize
docker run -d -P -v /nginxlogs:/var/log/nginx nginx //now we can see logs
 in our directory /nginxlogs
\end_layout

\begin_layout Subsection
Inspecting a Container
\end_layout

\begin_layout Standard
We can inspect a container by executing the command:
\end_layout

\begin_layout Itemize
docker inspect containerName //this will display all the details of the
 container in a JSON array
\end_layout

\begin_layout Standard
we can use grep to filter for a specific detail, for example:
\end_layout

\begin_layout Itemize
docker inspect containerName | grep IPAddress //this will show the IP address
 of the specified container
\end_layout

\begin_layout Subsection
Configurazione del demone docker
\end_layout

\begin_layout Standard
Il file di configurazione è localizzato in 
\begin_inset Quotes eld
\end_inset

/etc/default/docker
\begin_inset Quotes erd
\end_inset

, possiamo usare DOCKER_OPTS per controllare le opzioni di startup del demone
 quando runna come servizio, dobbiamo riavviare il servizio per fare in
 modo che le modifiche abbiano effetto con:
\end_layout

\begin_layout Itemize
sudo service docker restart //riavvia il demone, è possibile anche con sudo
 systemctl restart docker
\end_layout

\begin_layout Standard
possiamo invece ad esempio debuggare runtime avviando docker col comando:
\end_layout

\begin_layout Itemize
sudo docker -d –log-level=debug
\end_layout

\begin_layout Subsection
Security
\end_layout

\begin_layout Standard
Docker helps make applications safer as it provides a reduced set of default
 privileges and capabilities, namespaces provide an isolated view of the
 system, each container has its own set of:
\end_layout

\begin_layout Itemize
IPC
\end_layout

\begin_layout Itemize
network stack
\end_layout

\begin_layout Itemize
rootfs
\end_layout

\begin_layout Itemize
etc...
\end_layout

\begin_layout Standard
Processes running in one container cannot see and effect processes in another
 container, the technology at the base of all this, is 
\begin_inset Quotes eld
\end_inset

Control Groups
\begin_inset Quotes erd
\end_inset

 or CGroups which isolate resource usage per containers, anyway we must
 ensure that a compromised container won't bring down the entire host by
 exhausting resources.
 Quick security considerations are:
\end_layout

\begin_layout Itemize
docker daemon service must be run only as root
\end_layout

\begin_layout Itemize
watch who we add to the docker group
\end_layout

\begin_layout Itemize
if binding the daemon to a TCP socket, secure it with TLS
\end_layout

\begin_layout Itemize
use linux hardening solution, such as:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
apparmor
\end_layout

\begin_layout Itemize
SELinux
\end_layout

\begin_layout Itemize
GRSEC
\end_layout

\end_deeper
\begin_layout Subsection
Private Registry (alternative to DockerHub)
\end_layout

\begin_layout Standard
We can run a new container using the registry image with:
\end_layout

\begin_layout Itemize
docker run -d -p 5000:5000 registry:2.0 //we must run an image from dockerhub
 to make our own registry
\end_layout

\begin_layout Standard
once we have downloaded it, we can verify that it is running with 
\begin_inset Quotes eld
\end_inset

docker ps
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
now to push and pull from our private registry we can do:
\end_layout

\begin_layout Itemize
docker tag <imageID> myserver.net:5000/my-app:1.0
\end_layout

\begin_layout Standard
then
\end_layout

\begin_layout Itemize
docker push myserver.net:5000/my-app:1.0 //where instead of myserver.net we
 can even put an IP address
\end_layout

\begin_layout Standard
while to pull an image from our registry we do:
\end_layout

\begin_layout Itemize
docker pull myserver.net:5000/my-app:1.0
\end_layout

\begin_layout Standard
let's see another example (done on localhost):
\end_layout

\begin_layout Standard
we first rename an image with:
\end_layout

\begin_layout Itemize
docker tag 91jnu21e9122 localhost:5000/myhello-world:1.0
\end_layout

\begin_layout Standard
then we do:
\end_layout

\begin_layout Itemize
docker push localhost:5000/myhello-world:1.0
\end_layout

\begin_layout Standard
notice that when we pull from an IP address we'll get an error if we are
 not using SSL/TLS, so we must modify docker options, but before we stop
 the docker daemon, with 
\begin_inset Quotes eld
\end_inset

sudo systemctl stop docker
\begin_inset Quotes erd
\end_inset

 and we do:
\end_layout

\begin_layout Itemize
sudo vim /etc/default/docker
\end_layout

\begin_layout Standard
and we modify the line:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DOCKER_OPTS="--insecure-registry 104.131.142.17:5000"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then we restart the docker daemon.
\end_layout

\begin_layout Subsection
Docker Compose
\end_layout

\begin_layout Standard
Docker compose is a tool for creating and managing multi container applications,
 containers are all defined in a single file colled 
\begin_inset Quotes eld
\end_inset

docker-compose.yml
\begin_inset Quotes erd
\end_inset

, and each container runs a particulart component/service of our application,
 for example:
\end_layout

\begin_layout Itemize
web front end
\end_layout

\begin_layout Itemize
user authentication
\end_layout

\begin_layout Itemize
payments
\end_layout

\begin_layout Itemize
database
\end_layout

\begin_layout Standard
container links should be defined and compose will spin up all our containers
 in a single command.
 We know that we can start different containers and link them together,
 but the number of components grows, this is very impractical, so compose
 helps us in this.
\end_layout

\begin_layout Section
Useful Things
\end_layout

\begin_layout Subsection
Removing all the intermediate layers by exporting a container into a new
 image
\end_layout

\begin_layout Standard
Let's say we have an image which have committed several times, this image
 will contain all the history of the commissions which have been done, we
 first have to run the container in which we are interested in and then
 export this snapshot with:
\end_layout

\begin_layout Itemize
docker export my-running-image-id > ~/my_image.tar //the provided id must
 be the one we see in 
\begin_inset Quotes eld
\end_inset

docker ps
\begin_inset Quotes erd
\end_inset

, N.B.: The container must be running, export works with running containers
\end_layout

\begin_layout Standard
then now we can delete all the containers we have in the docker directory
 
\begin_inset Quotes eld
\end_inset

/var/lib/docker/containers/
\begin_inset Quotes erd
\end_inset

, or first delete the easy ones with:
\end_layout

\begin_layout Itemize
docker rmi -f <container ID>
\end_layout

\begin_layout Standard
once we have removed even the images contained in the docker directory we
 have to import our tarball archive, we can do this with:
\end_layout

\begin_layout Itemize
docker import ~/my_image.tar
\end_layout

\begin_layout Standard
our image if imported in this way will have name and repo name set to 
\begin_inset Quotes eld
\end_inset

<none>
\begin_inset Quotes erd
\end_inset

, now we can rename the image with:
\end_layout

\begin_layout Itemize
docker tag imageID repoName:imageName
\end_layout

\begin_layout Section
LXC
\end_layout

\begin_layout Standard
LXC sta per Linux Containers, ed è una tecnologia di virtualizzazione, utile
 nel momento in cui dobbiamo virtualizzare un sistema operativo che può
 usare il nostro stesso kernel, abbiamo in questo modo significativi vantaggi
 in termini di velocità e prestazioni in genere.
 Vediamo come configurare ed usare LXC.
\end_layout

\begin_layout Standard
Una volta installato con ad esempio:
\end_layout

\begin_layout Itemize
sudo apt-get install lxc
\end_layout

\begin_layout Standard
una volta installato è utile controllare se il kernel utilizzato sia compatibile
 con tutto, altrimenti dobbiamo porre rimedio, il comando per controllare
 la configurazione è:
\end_layout

\begin_layout Itemize
lxc-checkconfig //mostra la lista di varie feature e mi dice se sono abilitate
 o meno, è meglio assicurarsi che siano abilitate tutte, altrimenti dobbiamo
 cambiare la configurazione del nostro kernel
\end_layout

\begin_layout Standard
per vedere una lista di immagini disponibili da scaricare eseguiamo:
\end_layout

\begin_layout Itemize
lxc-create -t download -n my-container
\end_layout

\begin_layout Section
Vagrant
\end_layout

\begin_layout Standard
Vagrant is a tool for building and managing virtual machine environments
 in a single workflow.
 With an easy-to-use workflow and focus on automation, Vagrant lowers developmen
t environment setup time, increases production parity, and makes the "works
 on my machine" excuse a relic of the past.
\end_layout

\end_body
\end_document
